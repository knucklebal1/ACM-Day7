# ACM-Day7
1. Stockbroker Grapevine（OpenJ_Bailian-1125）
·思路：
把每个经纪人看作顶点，经纪人传给其他经纪人看作有向边，时间数就是边权，环也就是经纪人到自己置为0，不通的置为inf，即无穷大,如果一个经纪人不能把消息传给剩余的其他经纪人，那么这个传递网络是破碎的，输出disjoint,否则我们只需寻找这个经纪人传递消息最长的那个时间(该经纪人传给所有人所需要的时间)，然后遍历所有的经纪人寻找最小的时间，即本题是求最长路径的最小值。
·总结：
核心是通过Floyd-Warshall算法计算所有节点对之间的最短路径，并通过遍历找到中心节点。
2. 树的直径（51Nod-2602）
·思路：
主要通过dfs方法求解，两次dfs：第一次是从任意一个节点出发，找距离它的最远节点maxa；第二次是从maxa出发，找到最远节点maxb；maxa和maxb之间的路径就是树的直径。
·总结：
求树的直径，可以用两次dfs实现这一过程
3. Invitation Cards（HDU-1535）
·思路：
图中的节点代表公交站点，边代表单向的公交线路，边的权重代表乘坐该线路的费用。中央检查站（CCS）是节点1。每个案例的输入为节点数P和边数Q，以及每条边的起点、终点和费用。那么该题可理解为计算从 CCS 到所有其他节点的最短路径（正向图）；需要计算从所有其他节点到 CCS 的最短路径（反向图）；最后将这两个结果相加，得到每个志愿者往返 CCS 的最小费用。由于题目中的边为正权边，可以用dijkstra算法计算最短路径：首先，调用dijkstra(1)计算从 CCS（节点 1）到所有其他节点的最短路径，并将这些路径的长度累加到ans中；然后，将正向图的邻接表和边数组替换为反向图的邻接表和边数组，再次调用dijkstra(1)计算从所有其他节点到CCS的最短路径，并将这些路径的长度累加到ans中。最后输出ans。
·总结：
通过正向图和反向图的计算，将问题分解为两个独立的最短路径问题，最终将结果相加得到总费用。
4. 战略游戏（洛谷-P2016）
·思路：
该题可看作一个树的最小顶点覆盖问题：需要在树的节点上放置最少数量的士兵，使得每条边至少有一个端点被士兵覆盖；士兵放置在一个节点上时，可以覆盖与该节点相连的所有边。在树结构上主要通过动态规划来解决。先用邻接表e[N]存储树的结构，f[N][2]数组储存动态规划的状态（f[x][0]表示在节点x不放置士兵时，以x为根的子树所需的最小士兵数量；f[x][1]表示在节点x放置士兵时，以x为根的子树所需的最小士兵数量）。再使用深度优先搜索（DFS）遍历树，从根节点开始递归计算每个节点的状态，对于每个节点x：如果x放置士兵（f[x][1]），则其子节点可以选择放置或不放置士兵；如果x不放置士兵（f[x][0]），则其所有子节点必须放置士兵。最后输出根节点为1的两种状态的最小值（最小士兵数量）。
·总结：
通过递归计算每个节点的两种状态（放置士兵或不放置士兵），并根据子节点的状态更新当前节点的状态。最终结果是根节点的两种状态的最小值，即所需的最小士兵数量。
5. 飞行路线（洛谷-P4568）
·思路：
该题可以看作一个带有约束条件的最短路径问题：n个城市对应顶点，m条航线对应边，价格对应边的权重，而航线是双向的，所以为无向图。需要在图中找到一条路径，使得路径中最多有k条边的费用为 0，其余边的费用总和最小。为了处理最多k条免费航线的约束，考虑构建一个分层图，将原图复制k+1层，每一层表示使用了多少条免费航线（第0层表示没有使用任何免费航线；第k层表示使用了k条免费航线），每一层中，节点的编号为原节点编号加上层数乘以n节点总数）。对于原图中的每条边(a, b, c)，代码在分层图中添加以下边：同一层中，添加一条费用为c的边（不使用免费航线）；不同层之间，添加一条费用为0的边（使用免费航线）。因为该题为正权边，所以可使用dijkstra算最小值：初始化距离数组dis将所有节点的距离设置为无穷大；将起点 \(s\) 的距离设置为 0，并将其加入优先队列；使用优先队列进行松弛操作，更新每个节点的最短距离。最后遍历所有层中的终点t，找到最小距离并输出。
·总结：
通过分层图和 Dijkstra 算法可以解决带有约束条件的最短路径问题。分层图的核心是将约束条件转化为图的结构，从而可以使用经典的最短路径算法。
